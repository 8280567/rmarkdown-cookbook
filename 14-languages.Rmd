# Other Languages {#other-languages}

Besides the R language, many other languages are supported in R Markdown through the **knitr** package. The language name is indicated by the first word in the curly braces after the three opening backticks. For example, the little `r` in ```` ```{r}```` indicates that the code chunk contains R code, and ```` ```{python}```` is a Python code chunk.

In **knitr**, each language is supported through a language engine. Language engines are essentially functions that takes the source code and options of a chunk as the input, and returns a character string as the output. They are managed through the object `knitr::knit_engines`. You may check the existing engines via:

```{r}
names(knitr::knit_engines$get())
```

[Section 2.7](https://bookdown.org/yihui/rmarkdown/language-engines.html) of the R Markdown Definitive Guide [@rmarkdown2018] has shown examples of using Python, Shell, SQL, Rcpp, Stan, JavaScript, CSS, Julia, C, and Fortran code in R Markdown. In this chapter, we will show more language engines. First, let's reveal how a language engine works by registering a custom language engine.

## Register a custom language engine {#custom-engine}

You can register a custom language engine via the `knitr::knit_engines$set()` method, which accepts a function as its input, e.g.,

```{r, eval=FALSE}
knitr::knit_engines$set(foo = function(options) {
  # the source code is in options$code;
  # just do whatever you want with it
})
```

This registers the `foo` engine, and you will be able to use a code chunk that starts with ```` ```{foo}````.

The engine function has one argument `options`, which is a list of chunk options of the code chunk, among which you can access the source code of the chunk as a character vector in `options$code`. For example, for the code chunk:

````md
```{foo}`r ''`
1 + 1
2 + 2
```
````

The `code` element of `options` would be a character vector `c('1 + 1', '2 + 2')`.

Language engines do not really have to deal with computer languages, but can process any text in a code chunk. First, we show a simple example of an engine that converts the content of a code chunk to uppercase:

```{r}
knitr::knit_engines$set(upper = function(options) {
  code <- paste(options$code, collapse = '\n')
  if (options$eval) toupper(code) else code
})
```

The key is that we apply the function `toupper` to the "code", and return the result as a single character string (by concatenating all lines of code by `\n`). Note that `toupper()` is applied only when the chunk option `eval = TRUE`, otherwise the original string is returned. This shows you how to make use of chunk options like `eval` inside the engine function. Similarly, you may consider adding `if (options$results == 'hide') return()` to the function body to hide the output when the chunk option `results = 'hide'`. Below is an example chunk that uses the `upper` engine, with its output:

::: {.infobox .tip data-latex="{tip}"}
````md
```{upper}`r ''`
Hello, **knitr** engines!
```
````

```{upper}
Hello, **knitr** engines!
```
:::

Next we show an example of an alternative Python engine named `py` and implemented by simply calling the `python` command via `system2()`:

```{r}
knitr::knit_engines$set(py = function(options) {
  code <- paste(options$code, collapse = '\n')
  out  <- system2(
    'python', c('-c', shQuote(code)), stdout = TRUE
  )
  knitr::engine_output(options, code, out)
})
```

To fully understand the above engine function, you need to know that:

1. Given Python code as a character string (`code` in the above function), we can execute the code via a command-line call `python -c 'code'`. That is what `system2()` does. We collect the (text) output by specifying `stdout = TRUE` in `system2()`.

1. You can pass the chunk options, source code, and text output to the function `knitr::engine_output()` to generate the final output. This function deals with common chunk options like `echo = FALSE` and `results = 'hide'`, so you do not need to take care of these cases.

A lot of language engines in **knitr** are defined in this way (i.e., using `system2()` to execute commands corresponding to languages). If you are curious about the technical details, you may check out the source code of most language engines in the R source code here: https://github.com/yihui/knitr/blob/master/R/engine.R.

Now we can use the new engine `py`, e.g.,

::: {.infobox .tip data-latex="{tip}"}
````md
```{py}`r ''`
print(1 + 1)
```
````

```{py, echo=FALSE}
print(1 + 1)
```
:::

You can even override existing language engines via `knitr::knit_engines$set()`, if you are sure that your versions are necessary or better than the existing ones. Usually we do not recommend that you do this because it may surprise users who are familiar with existing engines, but we want to make you aware of this possibility anyway.

## Write the chunk content to a file via the `cat` engine {#eng-cat}

<!-- https://github.com/yihui/rmarkdown-cookbook/issues/140 -->

Sometimes it could be useful to write to some files from inside the Rmd. If this
could be achieved using pure R code in a r code chunk, `knitr` as a little
unknown gem for this : the `cat` engine.

### About the `cat` engine 

The `cat` engine allows to write to a file some codes from a Rmarkdown chunk.
The file path is passed as an argument in the generic `engine.opts` chunk
options: `engine.opts = list(file = <file to write to>)`. The element in this
list will be pass to `base::cat()` function allowing to customize how the
content is written to file.

In this example, we will write to a temp file with `fs::path_temp()`. 

````md
```{cat, engine.opts = list(file = fs::path_temp('script.R'))}`r ''`
my_function <- function(x){ x+1 }
```
```` 

```{cat, engine.opts = list(file = fs::path_temp('script.R'))}
my_function <- function(x){ x+1 }
```

The content can be used by filling a chunk from that file. This is another trick made possible using the `code` chunk option. You'll see the content of the file

````md
```{r, code = readLines(fs::path_temp('script.R'))}`r ''`
```
````

This will render

```{r, code = readLines(fs::path_temp('script.R'))}
```

As the code above is executed, the function is available in any following r chunk.

```{r, results='hold'}
my_function(5)
rm(my_function)
```

And the file can be sourced as usual too.

```{r, results='hold'}
source(fs::path_temp('script.R'))
my_function(5)
rm(my_function)
```


Writing to an R script is not really a real use case example and the `cat`
engine can handle any format.

Here, we use it to write some yaml to a file. The default behavior for `cat`
engine is to show nothing in the output document. However, here we will also
show the content in the output R Markdown file. The `cat` engine understand the
field `lang` in `engine.opts` option or directly `class.source` chunk option for
html outputs (see Section \@ref(chunk-styling)). You can provide any language
supported by the syntax highlighting. These two chunks are equivalent:

````md
```{cat, engine.opts = list(file = fs::path_temp('demo.yml'), lang = "yaml")}`r ''`
a:
  aa: something
  bb: 1
b:
  aa: somethingelse
  bb: 2
```
````

````md
```{cat, engine.opts = list(file = fs::path_temp('demo.yml')), class.source = "yaml"}`r ''`
a:
  aa: something
  bb: 1
b:
  aa: somethingelse
  bb: 2
```
````

They will write to file and print the code with the chosen syntax highlighting, here `yaml`
```{cat, engine.opts = list(file = fs::path_temp('demo.yml'), lang = "yaml")}
a:
  aa: something
  bb: 1
b:
  aa: somethingelse
  bb: 2
```

As previously, the file can be accessed later on and read into R
```{r}
yaml::read_yaml(fs::path_temp('demo.yml'))
```


```{r cleaning, include = FALSE}
unlink(c(fs::path_temp('demo.yml'), fs::path_temp('script.R')))
```

### Generate a template file from inside the rmarkdown

<!-- https://github.com/yihui/rmarkdown-cookbook/issues/149 -->

As detailed in section \@ref(chunk-styling), `css` chunk can directly be used to
apply custom style. However, it is also possible to provide a custom css file to
pandoc directly to be used with the html output and the `cat` engine can be used
to write this css file from the Rmarkdown.

One important key is that all chunks are executed before pandoc conversion. This
means it is possible in the yaml header to link to a file that does not exist
and will be created when rendering the document.

This complete example shows how to generate `my_custom.css` from a chunk in the
document while telling pandoc to use this css with the yaml field `css:
my_custom.css`

```{r, echo = FALSE, comment=""}
import_example("generate-css-cat-engine.Rmd")
```

This could also be used to generate any file that can be given to pandoc, like
an `in_header` tex file for a `pdf_document` output.^[Those yaml options for
pandoc can be found in *R Markdown Definitive Guide* [@rmarkdown2018]]

```{r, echo = FALSE, comment=""}
import_example("generate-latex-header-with-cat-engine.Rmd")
```

