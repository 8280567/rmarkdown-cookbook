# Output Hooks {#output-hooks}

With **knitr**, you have control over every piece of output from your code chunks, such as source code, text output, messages, and plots. The control is achieved through "output hooks", which are a series of functions that take a piece of output as the input (typically a character vector), and return a character vector to be written to the output document. This may not be easy to understand for now, but hopefully you can see the idea more clearly with a small example below explaining how the output of a simple code chunk is rendered through **knitr**'s output hooks.

Consider this code chunk with one line of code:

````md
```{r}`r ''`
1 + 1
```
````

After **knitr** evaluates the code chunk, it gets two output elements, and both are stored as character strings: the source code `"1 + 1"`, and the text output `"[1] 2"`. These character strings will be further processed by chunk hooks for the desired output format. For example, for Markdown documents, **knitr** will wrap the source code in a fenced code block with a language name. This is done through the `source` hook, which more or less looks like this function:

```{r, eval=FALSE}
# for the above case, `x` is a character string "1 + 1"
function(x, options) {
  # the little "r" here indicates the language name
  paste(c('```r', x, '```'), collapse = '\n')
}
```

Similar, the text output is processed by the `output` hook that looks like this function:

```{r, eval=FALSE}
function(x, options) {
  paste(c('```', x, '```'), collapse = '\n')
}
```

So the final output of the above code chunk is:

````md
```r
1 + 1
```

```
[1] 2
```
````

The actual hooks are more complicated than the two functions above, but the idea is the same. You may obtain the actual hooks from the object `knit_hooks` via the `get()` method, e.g.,

```{r, eval=FALSE}
knitr::knit_hooks$get('source')
knitr::knit_hooks$get('output')
# or knitr::knit_hooks$get(c('source', 'output'))
```

Unless you are truly interested in making contributions to the **knitr** package, we do not recommend that you read the source code of these built-in hooks, which can be found in the scripts named in the form `hooks-*.R` at https://github.com/yihui/knitr/tree/master/R (e.g., `hooks-md.R` contains hooks for R Markdown documents). As a **knitr** user, it usually suffices if you know how to create custom output hooks by taking advantage of the built-in hooks. You will learn that in several examples in this chapter, and we show the basic idea below.

A custom output hook is registered through the `set()` method on `knit_hooks`. Because this method will override the existing default hook, we recommend that you save a copy of existing hook, process the output elements in your own way, and pass the results to the default hook. The usual syntax is:

```{r, eval=FALSE}
# using local() is optional here (we just want to avoid creating unnecessary global variables like `hook_old`)
local({
  hook_old = knitr::knit_hooks$get('NAME')  # save the old hook
  knitr::knit_hooks$set(NAME = function(x, options) {
    # now do whatever you want to do with x, and pass the
    # new x to the old hook
    hook_old(x, options)
  })
})
```

Here `NAME` is the name of the hook, which can be one of the following values:

- `source`: processing the source code.

- `output`: processing text output.

- `warning`: processing warnings (usually from `warning()`).

- `message`: processing messages (usually from `message()`).

- `error`: processing error messages (usually from `stop()`).

- `plot`: processing plot file paths.

- `inline`: processing output from inline R expressions.

- `chunk`: processing output from the whole chunk.

- `document`: processing the whole document.

The meaning of the argument `x` in the hook functions is explained in the above list. For the `options` argument of a hook, it denotes the chunk options (as a list) for the current code chunk. For example, if you set `foo = TRUE` on a chunk, you can obtain its value via `options$foo` in the hook. The `options` argument is not available to the `inline` and `document` hooks.

Output hooks give you the ultimate control over every single piece of your chunk and document output. Compared with chunk options, which often have predefined purposes, output hooks can be much more powerful since they are user-defined functions, and you can do anything you want in functions.

## Redact source code {#hook-hide}

Sometimes we may not want to fully display our source code in the report. For example, you may a password in a certain line of code. We mentioned in Section \@ref(hide-one) that you can use the chunk option `eval` to select which expressions in the R code to display (e.g., show the second expression via `echo = 2`). In this section, we provide a more flexible method that does not require you to specify the indices of expressions.

The basic idea is that you add a special comment to the code (e.g., `# SECRET!!`). When this comment is detected in a line of code, you omit that line. Below is a full example using the `source` hook:

`r import_example('hook-secret.Rmd')`

The key part in the above `source` hook is this line, which matches the trailing comment `# SECRET!!` in the source code vector `x` via `grepl()` and exclude the matches:

```{r, eval=FALSE}
x <- x[!grepl('# SECRET!!$', x)]
```

Precisely speaking, the above hook will exclude whole _expressions_ containing the trailing comment `# SECRET!!`, instead of individual lines, because `x` is actually a vector of R expressions. For example, for the code chunk below:

```{r, source-hook-x, eval=FALSE}
1 + 1
if (TRUE) {
  1:10
}
```

The value of `x` in the `source` hook is:

```{r, eval=FALSE}
c("1 + 1", "if (TRUE) {\n  1:10\n}")
```


If you want to hide lines instead of expressions of R code, you will have to split `x` into individual lines. You may consider using the function `knitr:::split_lines()`. The body of the hook function will be:

```{r, eval=FALSE}
x <- knitr:::split_lines(x)  # split into individual lines
x <- x[!grepl('# SECRET!!$', x)]
x <- paste(x, collapse = '\n')  # combine into a single string
hook_source(x, options)
```

This example shows you how to manipulate the source code string, and `grepl()` is certainly not the only choice of string manipulation. In Section \@ref(hook-number), we will show another example.

## Add line numbers to source code {#hook-number}

In this section, we show an example of defining a `source` hook to add line numbers as comments to the source code. For example, for this code chunk:

````md
```{r}`r ''`
if (TRUE) {
  x <- 1:10
  x + 1
}
```
````

We want the output to be:

```{r, eval=FALSE, tidy=FALSE}
if (TRUE) {    # 1
  x <- 1:10    # 2
  x + 1        # 3
}              # 4
```

The full example is below:

`r import_example('hook-number.Rmd')`

The main trick in the above example is to determine the number of spaces needed before the comment on each line, so the comments can align to the right. The number depends on the widths of each line of code. We leave it to readers to digest the code in the hook function. Note that an internal function `knitr:::v_spaces()` is used to generate spaces of specified lengths, e.g.,

```{r}
knitr:::v_spaces(c(1, 3, 6, 0))
```

## Scrollable code chunks {#hooks-scroll}

It was shown in Section \@ref(html-scroll) how we can use custom CSS to add a scroll bar to the output code chunks. To highlight the use of code chunks, we extend the example here to allow for user-specified maximum heights to be provided to chunks.

Firstly, we define the custom hook. In this chunk, we need to insert the formatting required to style the scroll bar. The variable `max_height` is used to control the maximum height of the code chunk:

```{r, eval=FALSE}
knitr::knit_hooks$set(output = function(x, options){
  if(!is.null(options$max_height)){
    paste('<pre style = "max-height:',
          options$max_height, 
          ';float: left; width: 910px; overflow-y: auto;">',
          x,
          "</pre>",
          sep = "")
  }else{
    x
  }
  
})
```

To use this option, we can specify the option within the code chunk header.

````
```{r max_height = "200px"}`r ''`
print(cars)
```
````

## Output figures in HTML5 format

By default, images in R Markdown are translated to `<img src='...' alt='...'>` in the HTML output. This demo shows how to use the HTML5 `<figure>` tag to display images in R Markdown. Firstly we must define the custom hook as follows:

```{r, eval=FALSE}
# Reconfigure the plot hook
library(knitr)
knit_hooks$set(plot = function(x, options) {
  paste('<figure><img src="',
        opts_knit$get('base.url'), paste(x, collapse = '.'),
        '"><figcaption>', options$fig.cap, '</figcaption></figure>',
        sep = '')
})
```

One motivation for this is that we could use CSS to customise the output using the HTML5 specification, and readers may want to check out this [website](https://www.w3.org/Style/Examples/007/figures.en.html) for some ideas. For example, we could add a border to the plot and then change the background colour of the figure caption text:

```{css}
figure {
  border: thin silver solid;
  padding-top: 0;
}
figcaption {
  padding: 0.5em;
  border: thin silver solid;
  background: #D2F0F7;
}
```

Having specified the custom hook and CSS, the output of an example figure is shown in Figure \@ref(fig:hookHTML5). A full reproducible example is provided in the examples [online](https://github.com/dr-harper/rmarkdown-cookbook/blob/master/examples/hook-html5-figures.Rmd).

```{r hookHTML5, fig.cap = "Customised Figure Output styled by HTML5 CSS"}
knitr::include_graphics("images/hookHtml5Images.png", dpi = NA)
```






```{r eval = FALSE}
library(knitr)
hook_output <- knit_hooks$get("output")
knit_hooks$set(output = function(x, options) {
   lines <- options$output.lines
   if (is.null(lines)) {
     return(hook_output(x, options))  # pass to default hook
   }
   x <- unlist(strsplit(x, "\n"))
   more <- "..."
   if (length(lines)==1) {        # first n lines
     if (length(x) > lines) {
       # truncate the output, but add ....
       x <- c(head(x, lines), more)
     }
   } else {
     x <- c(if (abs(lines[1])>1) more else NULL, 
            x[lines], 
            if (length(x)>lines[abs(length(lines))]) more else NULL
           )
   }
   # paste these lines together
   x <- paste(c(x, ""), collapse = "\n")
   hook_output(x, options)
 })
```



