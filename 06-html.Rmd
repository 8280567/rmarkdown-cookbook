# HTML Output

How to customise the appearance of HTML outputs.

## Change Chunk Styling {#chunk-styling}

<!-- https://stackoverflow.com/questions/41030477/changing-chunk-background-color-in-rmarkdown -->

We can customize the style of code chunks and outputs using the arguments `class.source` and `class.output`. One way this can be useful is motivated by the original [Stack Overflow question](http://stackoverflow.com/q/41030477/559676) on how we use **knitr** to help us to emphasize "bad" coding practices.

By default,  R Markdown will include the Bootstrap framework. This can make things very easy for you to signify your code and your output. Bootstrap defines some [CSS classes for backgrounds](http://getbootstrap.com/css/#helper-classes-backgrounds): `"bg-primary"`, `"bg-success"`, `"bg-info"`, `"bg-warning"`, and `"bg-danger"`.

For example, we are warned that the normal subsetting of a data frame can be type-unstable. To show this here,  the chunk options are set: `class.source = 'bg-warning', class.output = 'bg-warning'`.

````
```{r df-drop, class.source='bg-warning', class.output='bg-warning'}`r ''`
mtcars[, "mpg"]
```
````

In our output document, this will create the code chunk as shown in Figure \@ref(fig:bgWarning).

```{r bgWarning, echo = FALSE, fig.cap = "Output of customised code chunk"}
knitr::include_graphics("images/bgWarning.png", dpi = NA)
```

To make sure that we return a data frame, we set the argument `drop = FALSE`. Here the chunk options are set: `class.source = 'bg-success', class.output = 'bg-success'`.

````
```{r df-drop-ok, class.source='bg-success', class.output='bg-success'}`r ''`
mtcars[, "mpg", drop=FALSE]
```
````

### Using Custom CSS

If we wish to specify custom styling options, we can include a CSS file by setting a parameter in the YAML header ([reference](http://rmarkdown.rstudio.com/html_document_format.html#custom_css)). You can also include a chunk of CSS code, as is done here. Note that for this example, only `class.source` is set.

````
```{css echo=FALSE}`r ''`
.chunk-style{
  background-color: #F5B7B1;
  border: 1px solid #797D7F;
  border-radius: 1px;}
```

```{r df-drop-2, class.source='chunk-style'}`r ''`
mtcars[, "mpg"] 
``` 
````

The output style is shown in Figure \@ref(fig:bgCustom).

```{r bgCustom, echo = FALSE, fig.cap = "Custom Background styling as defined by CSS"}
knitr::include_graphics("images/bgCustom.png", dpi = NA)
```

### Setting Default Style for Document

If we wish for all code chunks in the document to use our newly created style, we can add the `class.source` to the global knitr options.:

```{r, echo = TRUE, eval = FALSE}
knitr::opts_chunk$set(class.source='chunk-style')
```




## Scrollable Code Chunks {#html-scroll}

If we are including large amounts of code within our documents, we may want the code chunks to be limited in height with a scroll bar to navigate through the full details. Such a code chunk is highlighted in Figure \@ref(fig:scrollableCode). Here we demonstrate several ways in which this behaviour could be implemented.

```{r scrollableCode, echo = FALSE, fig.cap = "A Scrollable Code chunk using custom CSS"}
knitr::include_graphics("images/scrollableCode.png", dpi = NA)
```

### Overwriting the Default CSS

The simplist way of adding a scroll bar is to overwrite the global CSS options for the document. This will change the behaviour of all code chunks within the document. This requires us to specify the following CSS, where the user can set the height of the box using the `max-height` option:

```{css, eval = FALSE}
pre {
  max-height: 300px;
  float: left;
  width: 910px;
  overflow-y: auto;
}

pre.r {
  max-height: none;
}
```

### Specifing Additional CSS

If you would desire more control over when the scroll bar is used, you may prefer to specify another style class which we can used when required. Below, we have created an additional class called 'scroll' which we can include within our R Markdown document:

```{css, eval = FALSE}
.scroll {
  max-height: 300px;
  float: left;
  width: 910px;
  overflow-y: auto;
}
```

To use this class, we can specify the 'class.output' option within the code chunk header:

````
```{r, class.output = "scroll"}`r ''`
print(cars)
```
````

### User-specified chunk height

This example is extended further within Section \@ref(hooks-scroll), which uses chunk hooks to allow for user-specified heights.

## Tabbed headings

<!--https://stackoverflow.com/questions/38062706/rmarkdown-tabbed-and-untabbed-headings-->

## Embed the Rmd source file in the HTML output file {#embed-rmd}

When you share an HTML output page with others, they may want the Rmd source file, too. For example, they may want to change the Rmd source and compile the report by themselves. You can use the option `code_download` to embed a copy of the Rmd source file in the HTML output file:

```yaml
output:
  html_document:
    code_download: true
```

After the option is turned on, the HTML output page will contain a download button, and readers of the page can hit the button to download the Rmd source file.

## Embed arbitrary files in the HTML output file {#embed-file}

As mentioned in Section \@ref(embed-rmd), we can embed a copy of the Rmd source document in the HTML output file. Sometimes the Rmd source file alone may not be enough to reproduce the report. For example, the report may need an external data file. There is a series of functions in the **xfun** package that enable you to embed arbitrary files in the HTML output file. To use these functions, make sure you have the following R packages available:

```{r, eval=FALSE}
xfun::pkg_load2(c('base64enc', 'htmltools', 'mime'))
```

Then you can use one of the functions `xfun::embed_file()`, `xfun::embed_dir()`, or `xfun::embed_files()` in an R code chunk to embed one or multiple files or an entire directory in the HTML output, e.g.,

````md
```{r echo=FALSE}`r ''`
# a single file
xfun::embed_file('source.Rmd')

# multiple files
xfun::embed_files(c('source.Rmd', 'data.csv'))

# a directory
xfun::embed_dir('data/', text = 'Download full data')
```
````

You can also provide the list of files programmatically, e.g.,

```{r eval=FALSE}
# embed all Rmd and csv files
xfun::embed_files(list.files('.', '[.](Rmd|csv)$'))
```

For multiple files, they are first compressed to a zip file, and the zip file will be embedded. These functions return a link, which a reader can click on the HTML page to download the embedded file.

You can learn more technical details behind these functions from the help page `?xfun::embed_file` or the blog post at https://yihui.name/en/2018/07/embed-file/.

## Hardcore HTML users {#html-hardcore}

In Section \@ref(latex-hardcore), we mentioned that if you feel the constraint of Markdown (due to its simplicity) is too strong, you can embed code chunks in a pure LaTeX document instead of Markdown. Similarly, if you are familiar and comfortable with writing raw HTML code, you can intermingle code chunks with HTML, too. Such documents have the conventional filename extension `.Rhtml`.

In an `Rhtml` document, code chunks are embedded between `<!--begin.rcode` and `end.rcode-->`, and inline R expressions are embedded in `<!--rinline -->`. Below is a full `Rhtml` example. You can save it to a file named `test.Rhtml`, and use `knitr::knit("test.Rhtml")` to compile it. The output will be an HTML (`.html`) file. In RStudio, you can also hit the `Knit` button on the toolbar to compile the document.

`r import_example('knitr.Rhtml')`
